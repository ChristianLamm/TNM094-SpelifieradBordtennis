<!DOCTYPE html>
<html>
  <head>
    <script src="https://pixijs.download/release/pixi.min.js"></script>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <script type="module">
      //setting up the websocket - this will receive coordinates in format "xCoord,yCoord"
      const ws = new WebSocket("ws://localhost:12345");

      // importing the stage
      import {
        tableWidth,
        tableHeight,
        bgBlue,
        white,
        initializeApp,
      } from "./common.js";

      //importera functions
      import {
        changeTexture,
        changeTextureTemporarily,
        hitCheck,
        generateRandomCoordinates,
        moveSprite,
      } from "./functions.js";

      (async () => {
        const { app, scoreText, updateScoreText } = await initializeApp();
        
        console.log(`Game initialized with dimensions: ${tableWidth}x${tableHeight}`);

        //-------------------------GAMECODE GOES HERE--------------------------
        //load images and set them as variables
        await PIXI.Assets.load("images/virus.png");
        await PIXI.Assets.load("images/virus_dmg.png");
        await PIXI.Assets.load("images/virus_dead.png");

        const virusTex = PIXI.Texture.from("images/virus.png");
        const virus_dmgTex = PIXI.Texture.from("images/virus_dmg.png");
        const virus_deadText = PIXI.Texture.from("images/virus_dead.png");

        // Create the target and add it to the stage
        let target = new PIXI.Sprite(virusTex);
        target.scale.set(0.5, 0.5); // Scale the target to half its size
        
        // Start with the target in a random position
        let [startX, startY] = generateRandomCoordinates();
        target.x = startX;
        target.y = startY;
        
        app.stage.addChild(target);

        // Create the marker
        await PIXI.Assets.load("images/yellowMarker.png");
        let marker = PIXI.Sprite.from("images/yellowMarker.png");

        // Create a smaller marker
        await PIXI.Assets.load("images/yellowMarker.png");
        let smallMarker = PIXI.Sprite.from("images/yellowMarker.png");
        smallMarker.scale.set(0.5, 0.5); // Scale the marker to half its size

        //-------------------------------------------------------------------------------------------------
        // GAMIFICATION
        //-------------------------------------------------------------------------------------------------

        let targetCounter = 0;
        target.interactive = true;
        target.buttonMode = true;

        //körs när meddelande tas emot från ws server
        ws.onmessage = function (event) {
          let eventDataValue = event.data; // Get the data from WebSocket
          console.log("Received raw data:", eventDataValue);
          
          // Debug the data type and format
          console.log("Data type:", typeof eventDataValue);
          console.log("Data content:", eventDataValue);
          
          // First try the X/Y format (from MATLAB)
          let xCoord, yCoord;
          
          // Check if the data might be in X123Y456 format
          if (typeof eventDataValue === 'string' && eventDataValue.includes('X') && eventDataValue.includes('Y')) {
            const xMatch = eventDataValue.match(/X(\d+)/);
            const yMatch = eventDataValue.match(/Y(\d+)/);
            
            if (xMatch && yMatch) {
              xCoord = parseInt(xMatch[1], 10);
              yCoord = parseInt(yMatch[1], 10);
              
              // Convert to game coordinates if needed (assuming table dimensions have been set)
              // This assumes the coordinate bridge is not being used
              if (typeof TABLE_WIDTH_MM !== 'undefined' && typeof TABLE_HEIGHT_MM !== 'undefined') {
                xCoord = Math.round((xCoord / TABLE_WIDTH_MM) * tableWidth);
                yCoord = Math.round((yCoord / TABLE_HEIGHT_MM) * tableHeight);
              }
            }
          } 
          // Try the comma-separated format (from coordinate bridge)
          else if (typeof eventDataValue === 'string' && eventDataValue.includes(',')) {
            const parts = eventDataValue.split(',');
            if (parts.length >= 2) {
              xCoord = parseFloat(parts[0]);
              yCoord = parseFloat(parts[1]);
            }
          }
          
          // If we still don't have valid coordinates, log an error
          if (isNaN(xCoord) || isNaN(yCoord)) {
            console.error("Failed to parse coordinates from:", eventDataValue);
            return;
          }
          
          console.log(`Parsed game coordinates: (${xCoord}, ${yCoord})`);
          
          // Place the marker at the hit location
          smallMarker.x = xCoord - smallMarker.width / 2;
          smallMarker.y = yCoord - smallMarker.height / 2;
          app.stage.addChild(smallMarker);
          
          // Check if the hit is on target
          if (hitCheck(target, xCoord, yCoord)) {
            console.log("Hit on target!");
            targetCounter += 1;
            updateScoreText(targetCounter);

            if (targetCounter % 5 == 0) {
              // Move the target to a new random position after 5 hits
              let [newTargetPosX, newTargetPosY] = generateRandomCoordinates();

              changeTextureTemporarily(target, virus_deadText);
              setTimeout(() => {
                target.x = newTargetPosX;
                target.y = newTargetPosY;
                moveSprite(target, newTargetPosX, newTargetPosY);
              }, 500);
            } else {
              changeTextureTemporarily(target, virus_dmgTex);
            }
          }

          // Remove the marker after a delay
          setTimeout(() => {
            app.stage.removeChild(smallMarker);
          }, 1000);
        };

        //kör när meddelande inte tas emot
        ws.onerror = function (err) {
          console.error("WebSocket error:", err);
        };

        // When the player clicks the target
        target.on("pointerdown", () => {
          target.interactive = false; // Make the target unclickable
          setTimeout(() => {
            target.interactive = true; // Re-enable clicking after 0.5 seconds
          }, 500);

          targetCounter += 1;
          updateScoreText(targetCounter);

          if (targetCounter % 5 == 0) {
            // Move the target to a new random position
            let [newTargetPosX, newTargetPosY] = generateRandomCoordinates();

            // Set a new position for the target
            changeTextureTemporarily(target, virus_deadText);
            setTimeout(() => {
              target.x = newTargetPosX;
              target.y = newTargetPosY;
              moveSprite(target, newTargetPosX, newTargetPosY);
            }, 500);
          } else {
            changeTextureTemporarily(target, virus_dmgTex);
          }
        });

        // Make the window clickable
        window.addEventListener("click", onClick);

        function onClick(event) {
          // Get the mouse coordinates relative to the Pixi.js canvas
          let rect = app.view.getBoundingClientRect();
          let x = event.clientX - rect.left;
          let y = event.clientY - rect.top;

          if (hitCheck(target, x, y)) {
            console.log("You hit the target!");
          } else {
            // Missed shot
            marker.x = x - marker.width / 2;
            marker.y = y - marker.height / 2;

            app.stage.addChild(marker);

            setTimeout(() => {
              app.stage.removeChild(marker);
            }, 1000);

            console.log(`Mouse clicked at x: ${x}, y: ${y}`);
          }
        }
      })();
    </script>
  </body>
</html>